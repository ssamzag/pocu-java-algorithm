# COMP 2500 중간고사 정리

## 1. Java 언어의 기본 문법

### Java의 문자열 비교 베스트 프랙티스

- 문자열이 참조형이란 사실을 잊지 말 것
- ==를 쓰지 말 것
- 그 대신 eqauls() 메서드를 사용할 것



### >>> 연산자

- 부호 없는 비트 이동 연산자
- 오른쪽으로 이동 후 남는 공간을 '0'으로 채움
- Java에는 부호 없는 자료형이 없기 때문에 이렇게 연산자를 따로 만듦



### foreach 스타일 for문

```java
int[] scores = {10, 20, 30, 40};
for(int score : scores)
{
	...
}
```

- 어떤 컬렉션이든 순회할 수 있는 반복문
- C에는 없지만 Java와 C#에 있음



### final 참조형 매개 변수

- 참조형 변수는 주소를 저장
- 따라서 final이 붙으면 그 주소만 변경 못 함
- 그 주소가 가리키는 값은 여전히 바꿀 수 있음



### Java의 열거형

- 열거형은 독자적 또는 클래스 내부에 선언 할 수 있음
- 각 원소에 원하는 값을 대입하지는 못함
- 열거형 개체를 만들 때는 new를 안씀
- Java의 열거형은 클래스형이기 때문에 멤버 변수와 메서드를 가질 수 있으나 데이터로만 사용할 것
  - 멤버 변수 및 메서드가 있을 경우 마지막 상수 끝에 ;를 붙여야 함





## 2. 개체지향 프로그래밍(OOP)의 필요성

### 데이터의 비인간화

- 절차적 언어에서는 구조체를 통해 이것을 보완하려 함
- 하지만, 여전히 데이터와 동작이 분리되어 있어 어떤 구조체가 어떤 함수랑 연관 있는지 찾기 복잡함



### 사람은 세상을 물체(Object)의 집합으로 인지

- 일반적인 이야기
  - 세상 모든 것을 물체로 보진 않음
  - ojbect를 프로그래밍에서 객체 또는 **개체**라 번역
  - 물체는 **상태**를 가질 뿐만 아니라 **동작**도 할 수 있음



### 절차적 프로그래밍은 매우 객관적

- 기준이 작동하는 기계이기에 매우 객관적
- 패러다임에 프로그래머의 주관이 개입할 여지가 적음





## 3. OOP의 4대 특성 소개

### 캡슐화

- 데이터와 그 데이터에 작용하는 메서드를 하나로 묶음
- 정보 숨기기 (data hiding): 개체 안에 있느 ㄴ데이터를 외부로부터 보호
  - 전부 혹은 일부
  - 외부: 다른 클래스에 속한 개체들



### 상속

- 이미 존재하는 개체를 기반으로 확장된 개체를 만드는 방법
  - 엄밀히 말하면 개체가 아니라 **클래스**
- 확장된 개체
  - 기존의 개체에 속한 데이터와 동작을 모두 물려 받음
  - 여기에 다른 데이터나 동작을 추가할 수 있음
- 실용적인 용도: 코드 중복을 막음
  - 여러 개체에 공통되는 데이터와 동작을 부모 개체로 만듦
  - 여러 개체는 각각 그 부모 개체를 상속 받음
  - 그 후 자기에게만 필요한 데이터나 동작을 추가
- 사람에게는 점진적 학습이 가장 효율적
  - 프로그래밍도 마찬가지



### 다형성

- 많은 사람들이 OOP의 핵심이라 여기는 특징
- **같은 지시**를 내렸는데 **다른 종류의 개체**가 **동작을 달리** 하는 것
  - 같은 지시: 동일한 함수 시그내처 호출
  - 달리 동작: 개체의 종류에 따라 실제로 실행되는 함수 구현 코드가 다름
- 어떤 함수 구현이 실행될지는 실행 중에 결정 됨
  - 이를 늦은 바인딩 (late binding) 이라고 함
- 일적인 함수 호출은 이른 바인딩 (early binding)
  - 컴파일 중에 결정 됨
- 다형성의 혜텍을 받으려면 상속 관계가 필요
  - 부모 개체에서 함수 시그내처를 선언
  - 자식 개체에서 그 함수를 다르게 구현 (오버라이딩, overriding)
- 실용적인 용도: 다른종류의 개체를 편하게 저장 및 처리 가능
- 엄밀히 말하면 여기가 설명한 다형성은 세 가지 다형성 중 하나
- **서브타임 (subtype) 다형성** 이라고 함
- 보통 다형성이라 하면 99.9% 이것을 의미



#### 참고: 다른 두 형태의 다형성

1. 애드혹(ad-hoc) 다형성
   - 함수 오버로딩, 연산자 오버로딩
   - 즉, 함수명은 같은데 매개변수 목록이 다름
2. 매개변수 다형성
   - C#과 Java의 제네릭 (Generic)
   - C++의 템플릿

- 허나 둘 다 일반적으로 다형성이라고 안 부름
- OOP하고도 상관 없음



### (데이터) 추상화

- 문헌에 따라 '데이터 추상화' 또는 '추상화'라고 함
- 추상화
  - 수학: 일반화라는 의미 (반의어: 구체화)
  - OOP: 개체 속에 있는 실제 데이터나 함수 구현 방법에 종속되지 않겠다는 뜻
- 데이터 추상화
  - 개체 사용 시 그 안에 정확히 어떤 데이터가 있는지 알 필요 없음
  - 개체 안에 있는 데이터에 직접 접근 불가
    - 그 대신 개체의 함수를 통해 접근
  - 즉, 캡슐화는 데이터 추상화를 이루는 방법 중 하나
- 추상화
  - 다형성을 통한 추상화
  - 추상 클래스 (abstract class)나 인터페이스 (interface)를 사용하는 추상화





## 4. 클래스와 개체

### 자연 세계에서의 클래스

- 생물학에서 클래스 (class)란 '강'을 의미
  - '종 (species)'이나 '과(family)'보다 상위 개념
- 어떤 개체든지 속한 클래스가 있음
- 같은 클래스에 속하는 개체는 비슷한 속성과 동작을 공유
- 프로그래밍에서 클래스의 개념도 이와 유사



### OOP에서의 클래스

- 새로운 개체를 만들때 사용하는 명세서
- 개체는 반드시 클래스로부터 만들어야 함
- 명세서에 담긴 내용
  - 속성(상태)
    - 멤버 변수, 필드로도 불림
  - 동작
    - 멤버 함수, 메서드, 메시지로도 불림
  - 기타등등



### 클래스 설명 시 흔히 사용하는 비유

- 청사진 (blue print)
- 붕어빵 틀
- 주물
- 물건을 생산하는 공장



### 인스턴스 (instance)

- 개체를 부르는 또 다른 표현
- 인스턴스의 뜻은 사례
- '어떤 클래스에 속하는 개체의 한 예'라는 의미
- 인스턴스화 (instantiation): 클래스로부터 개체 하나를 만드는 행위





## 5. 참조형과 포인터

### 참조형

- 자바에서는 이것은 참조형 (refrence type)이라고 함
- 자바는 기본 자료형 제외하면 모두 포인터 형
- 자바에 포인터가 없다는 것은 거짓말
  - '자바에서는 모든 것이 포인터다!' 라고 해도 될 정도 (예외: 기본 자료형)
  - 포인터 연산이 불가능 할 뿐
- C는 개체를 포인터 혹은 값으로 둘 다 전달 가능하나 Java는 포인터로만 전달 가능



### 개체 생성 시 멤버데이터의 초기화

- C구조체는 변수 선언 시 초기화가 안됨
  - C는 성능이 제일 중요
- 메모리에 남아있던 쓰레기 값이 그대로 유지 됨
- Java는 **0에 준하는 값**으로 초기화해 줌
  - int는 0
  - float는 0.0
  - 참조형은 null로
  - Java는 실수 방지가 중요
- 0이 아닌 다른값으로 초기화 하고 싶다면 선언문에 대입 가능



### . 연산자의 다른 의미

- C: 멤버 변수 접근 연산자
  - . 연산자: 구조체의 멤버 변수에 접근
  - -> 연산자: 포인터로 참조 중인 구조체의 멤버 변수에 접근 (.와 *을 합한 것)
- Java: 개체의 멤버에 접근 할 때 . 연산자를 사용
  - Java의 모든 개체는 포인터 형 (예외: 기본 자료형)
  - 따라서 .와 -> 구분이 필요 없음
- Java: 포인터 역참조 용 * 연산자가 없음
  - 주소를 직접 읽을 방법 자체가 없음
  - 따라서 언제나 그 주소에 저장된 값을 읽어 옴
  - 그 주소에 포인터 연산도 불가능





## 6. 생성자

```java
public <클래스명>(<매개변수 목록>)  {
	...
}
```

- 생성자라는 특별한 메서드가 이런 일을 담당
  - 개체 생성시에 자동으로 호출되는 특수한 함수
  - 반환형: 없음 (void가 아님)
  - 함수명: 클래스명과 동일



### 생성자 오버로딩에서 코드 중복을 피하는 방법

- 매개변수 수가 적은 생성자에서 매개변수 수가 많은 생성자를 호출
- this()를 이용하면 다른 생성자를 호출할 수 있음



### 기본 생성자 (default constructor)

- 프로그래머가 **생성자를 하나도 안 만들 경우 자동으로 생기는 생성자**
- **컴파일러가 알아서 매개변수 없는 생성자를 만들어 줌**
- 기본 생성자의 함수 바디 (body)는 비어 있음
  - 각 멤버 변수는 이미 0에 준하는 값으로 초기화됐기에 괜찮음
- 프로그래머가 생성자를 제공하면 기본 생성자는 생기지 않음



### 생성자로 초기화를 해야 하는 이유

- 개념상의 문제: 생성된 개체가 초기화 되어 있지 않는다는게 말이 될까?
- 생성자의 후조건: '개체의 상태는 개체 생성과 동시에 유효하다'





## 7. 접근 제어자(access modifier)

|  접근 제어자  | 클래스 내부 |    같은 패키지     |    자식 클래스     |        외부        |
| :-----------: | :---------: | :----------------: | :----------------: | :----------------: |
|    public     |  접근 가능  |     접근 가능      |     접근 가능      |     접근 가능      |
|   protected   |  접근 가능  |     접근 가능      |     접근 가능      | <u>접근 불가능</u> |
| 기본 / 패키지 |  접근 가능  |     접근 가능      | <u>접근 불가능</u> | <u>접근 불가능</u> |
|    private    |  접근 가능  | <u>접근 불가능</u> | <u>접근 불가능</u> | <u>접근 불가능</u> |

- 어떤 외부자들이 개체 속에 접근할 수 있는지 정의
- OP에서 주로 논하는 것은 public / protected / private

1. public: 누구나 접근 가능
2. protected: 자식들만 접근 가능
3. 생략할 경우: 같은 패키지에 속한 클래스들만 접근 가능
   - default 혹은 package 접근 제어자라 부름
4. private: 외부 접근 금지





## 8. getter/setter 메서드

### getter

- 멤버 변수를 반환하는 함수
- C#의 프로퍼티처럼 언어 자체의 기능은 아님



### setter

- 멤버 변수를 변경하는 함수



### getter/setter 함수를 통한 데이터 접근의 객관적인 장점

1. 추가적인 멤버 변수를 저장하지 않고 필요할 때마다 getter에서 계산 가능
2. setter에서 추가적인 로직을 실행할 수 있음
3. 상속을 통한 다형성 구현 가능



### getter/setter 베스트 프랙티스

- 대부분의 멤버 변수는 특별한 경우가 아니라면 private으로 선언
- 새 개체는 생성시 부터 유효 해야하며 이를 생성자를 통해 강제할 수 있음
- 사용자가 알 필요 없는 정보는 보여주지 않는게 정석이나 큰 문제가 없으므로 getter는 자유롭게 추가
- 이상적인 개체의 상태 수정법은 개체의 사용자가 어떤 동작을 지시하고 그로인한 동작의 결과로 개체 안에 있는 어떤 상태가 바뀌는 것이기 때문에 setter는 데이터를 직접 바꾸므로 가능한 고민후 추가
- setter 사용 시 개체가 불확실한 상태로 되는 경우를 최대한 막아야 함 (예: assert)





## 9. 캡슐화

클래스 만들기와 private 멤버 변수가 바로 **캡슐화**

> 1. 개체의 데이터 (=멤버 변수)와 동작 (=메서드)을 하나로 묶음
> 2. 내부의 데이터를 외부로부터 보호

- 사용자가 클래스 속을 알 필요가 없음
  - 사용자가 함수 속을 알 필요가 없는 것과 마찬가지
  - 이 개념은 추상화로 이어짐
- 함수를 분리할 때 적용했던 원칙을 클래스에도 적용할 것
  - 중복된 코드가 있다면 private 메서드로





## 10. 데이터 추상화

private 멤버 변수와 getter/setter가 **데이터 추상화**

- 추상 자료형 (abstract data type)쪽 관점
  - 사용자는 클래스를 자료형으로 사용할 수 있음
  - 그 클래스 안에 들어있는 멤버 변수가 정확히 뭔지 몰라도 됨
  - 그냥 클래스로부터 개체 생성 가능
- 절차적 데이터 추상화 (procedural data abstraction) 쪽 관점
  - 데이터를 직접 조작하는 대신 메서드를 호출
  - 이게 OOP라는 용어를 처음 주장했다는 소수설의 관점과 유사
  - 동작적 개체 (behavioral objects) 진영이라고 하기도 함 (정식 명칭 아님)
- OOP에서 추상화란 **어떤 구체적인 것에 직접 손대지 않겠다**는 의미



### 추상화의 단점

- 동작 없이 데이터만 있는 클래스는 쓸데없는 코드만 늘어남
  - 예: 웹 프로그래밍에서 많이 볼 수 있는 DTO (data trasfer object)
  - 그래서 이런 경우에는 그냥 public 데이터를 쓰기도 함
- 어떻게 추상화를 해야하는지 뚜렷한 객관적 기준이 없음
  - 사람은 뚜렷한 실체가 없는 개념을 이해하기 어려워 함
  - 이해하더라도 각자 달리 이해하기 쉬움
  - 나중에 다형성, 상속, 인터페이스에서 나오는 추상화에서 특히 문제





## 11. 클래스 다이어그램

- 어떤 시스템에 있는 클래스들을 보여주는 다이어그램(diagram)
  - 클래스 안에 들어있는 상태, 동작, 접근 제어자
  - 클래스 가느이 관계 (상속, 컴포지션 등)
- 시스템의 정적인 구조를 보여주기에 적합
- 먼 훗날 데이터베이스 설계할 때도 비슷한 다이어그램을 볼 것임
- UML (Unified Modeling Language)의 일부



### 클래스 다이어 그램의 범위

- 클래스 다이어그램은 다음의 것들을 표현

1. 클래스가 가지고 있는 상태
   - 상수는 멤버 변수 (상태)에 속하지 않는다
2. 클래스에 실행할 수 있는 동작의 목록
   - 실제 구현은 보여주지 않음
3. 클래스 간의 관계





## 12. 유연성과 재사용성

코드 유연성은 양날의 검이며 필요에 따라 유연성을 유연하게 조정해야 한다

- 유연성▲: 성능▼ 가독성▼ 재사용성▲

- 유연성▼: 성능▲ 가독성▲ 재사용성▼



## 13. 정적(static) 멤버 변수 및 메서드

### 정적 멤버 변수

- 멤버 변수에 static을 붙여주면 된다
- 정적 메서드와 같이 다이어 그램에서 밑줄을 그어 표시
- 이 멤버 변수의 소유주는 인스턴스가 아니라 클래스



### 정적 멤버 함수

- 멤버 함수 시그내처에 static만 붙여주면 됨
- 이 멤버 함수의 소유주는 인스턴스가 아니라 클래스
- 정적 멤버 함수를 호출 할 때는?

  - <클래스명>.함수명()
  - <u><개채명>.함수명() 이 방법도 가능하지만 사용하지 말것</u>
- 클래스 다이어그램에서 정적 멤버 함수 아래에 밑줄을 그어 표현
- 정적 메서드에서 비정적 메서드/변수 접근이 불가능
- **클래스에 속한 메서드**가 **개체에 속한 멤버(함수/변수)**에 **접근 불가**



### static 정리

1. C의 전역 변수/함수와 비슷한 기능
   - 접근 범위를 제어 할 수 있고 클래스 내부에 위치하기 때문에 이름 충돌이 적음
2. static 멤버 변수 및 멤버 함수는 클래스에 속함 (딱 하나만 존재)

3. static 아닌 것은 개체에 속함 (따라서 개체 수만큼 존재)
4. 비정적 → 정적: 접근 가능
5. 정적 →  비정적: 접근 불가능





## 14. 싱글턴

- 어떤 클래스에서 만들 수 있는 **인스턴스 수를 하나로 제한**하는 패턴
- 다음과 같은 조건을 충족하는 개체에 적합

1. 프로그램 실행 중에 **최대 하나만** 있어야 함
2. 이 개체에 **전역적으로 접근**이 가능해야 함

- 딱 하나(single)만 존재해야 하니 이름도 싱글턴(singleton)



### 싱글턴 패턴의 구조

- private 생성자
- static 메서드를 통해서만 개체를 얻어올 수 있음
- 아직 개체가 없는 경우
  - 개체를 생성 후 static 변수에 저장
  - static 변수에 저장된 개체를 반환
- 이미 개체가 있는 경우
- static 변수에 저장되어 있는 개체를 반환





## 15. 내포(nested) 클래스

- 클래스 안에 다른 클래스가 들어가 있는 모습
- 안에 들어 있는 클래스를 내포(nested) 클래스라고 함



### Java의 내포 클래스

- 크게 둘로 나뉨
  - 비정적 내포 클래스
    - 내부 클래스라고도 부름
  - 정적 내포 클래스
- C#, C++ 등의 언어에서는 **정적 내포 클래스**만 존재 
  - 이 경우에는 정적임에도 static을 붙이지 않음
- 그래서 보통 inner와 nested라는 용어를 혼용해서 사용
- Java 진영에서는 두 단어를 혼용하면 싫어하는 사람들도 있음



### 내포 클래스의 용도

1. 서로 연관된 클래스들을 그룹지을 수 있음

   - 패키지로 그룹 짓는 것도 가능
   - 하지만 클래스 속에 넣는 것이 더 긴밀한 그룹 (강한 캡술화)

2. 내포 클래스는 바깥 클래스의 private 멤버에 접근 가능

   - 하지만 그 반대의 경우는 불가능

   

### 내포 클래스와 접근 제어자

- 내포 클래스가 아닌 경우에는 protected와 private을 붙일 수 없음
- 내포 클래스는 protected와 private도 허용



### 비정적 내포(inner) 클래스 vs 정적 내포(nested) 클래스

1. 비정적 내포 클래스에서 외부 클래스의 private, public 멤버 변수에 직접 접근 → 허용
2. 정적 내포 클래스에서 외부 클래스의 private, public 멤버 변수에 직접 접근 → 컴파일 오류
3. 외부 클래스에서 비정적 내포 클래스의 private, public 멤버 변수에 직접 접근 → 컴파일 오류
4. 외부 클래스에서 정적 내포 클래스의 변수에 개체 생성 없이 직접 접근 → 컴파일 오류
5. 비정적 내포 클래스의 개체를 생성한 후 private/public 멤버 변수에 직접 접근 → 허용
6. 정적 내포 클래스의 개체를 생성한 후 private/public 멤버 변수에 직접 접근 → 허용
7. 비정적 내포 클래스에서 static 멤버 변수/메서드 정의 → 컴파일 오류
8. 정적 내포 클래스에서 static 멤버 변수/메서드 정의 → 허용





## 16. 상속

- 거의 모든 사람이 **OOP의 핵심**이라 여기는 특성
  - 초창기 OO에서 가장 중요한 특성이라 여겼음
  - 재사용성이 궁극의 목적이라 신봉하던 시대
  - 현재에도 상속을 지원하지 않으면 OO 언어라고 안 보는게 보통
- OOP의 또 다른 매우 중요한 특성인 <u>다형성의 기반</u>
- 영어권에서는 생물학적 유전을 interitance라고 표현하기도 함



### OOP에서의 상속이란?

이미 존재하는 클래스를 기반으로 새 클래스를 만드는 방법

- 새 클래스는 기존 클래스의 동작과 상태를 그대로 물려 받음 (유전)
- 그 외에 새 클래스만의 동작과 상태를 추가 가능 (진화)
- 물론 이 새 클래스를 상속해서 또 다른 클래스를 만들 수 있음



### 상속 시 생성자의 호출 순서

- 상속 시 생성자의 호출 순서는 부모부터 초기화 된다.
- 따라서 이 순서를 따른다
  1. 메모리에 개체 생성
  2. 부모 생성자 호출
  3. 자식 생성자 호출



### super 키워드

- super는 현 개체의 **부모 부분**을 가리킴
- super()라고 코드를 작성하면 부모의 생성자를 호출
- 멤버 변수나 메서드를 호출할 때도 사용 가능



### 부모에 멤버에 접근하기

- super.<멤버변수명>
- this.<멤버변수명>으로도 접근 가능



### 상속 vs 컴포지션

- 둘 다 재사용성을 위한 방법
- 상속으로 해결할 수 있는 많은 문제를 컴포지션으로도 가능
  - 그 반대도 가능
  - 순전히 기술적인 관점
- 일반적인 가이드 라인
  - has-a 관계: 컴포지션
  - is-a 관계: 상속





## 17. 개체의 명시적/암시적 캐스팅

### 자식을 부모에 대입하는 건 암시적 캐스팅

- 부모 ← 자식은 사실 캐스팅
- 이걸 컴파일러가 암시적(implicit)으로 해준 것일 뿐
- 왜? is-a 관계이기 때문에 해준다
- 따라서 코드에서 부모로의 명시적 캐스팅은 거의 99.99% 생략



### 부모를 자식에 대입하는 명시적 캐스팅

- 자식 ← 부모는 명시적 캐스팅으로만 가능
- 프로그래머가 '내가 뭐 하는지 알아! 날 믿고 컴파일 해!'라고 지시

1. 부모를 자식으로 캐스팅 후 호출
2. 컴파일 잘 됨



### 전혀 상관없는 클래스로 캐스팅 하면?

- 컴파일러가 잡아줌



### 컴파일러가 못 잡아내는 경우

- 이럴 떄는 실행 중에 예외 발생
  - ClassCastException
  - 예외 처리(exception handling)에 대해서는 나중에 자세히 설명





## 18. RTTI(run time type identification) 기능

- 부모형 변수에 저장된 개체가 실제 어떤 자식형인지 실행중에 알 수 있는 기능
- 매니지드 언어(C#, Java 등)들은 보통 RTTI를 지원
- 성능 또는 메모리가 중요한 경우에는 사용하지 말아야 함



### instanceof 연산자

```java
<변수명> instanceof <클래스명>
```

- 개체가 특정 클래스의 인스턴스인지 판단하는 연산자
  - 맞으면 참을 반환
  - 틀리면 거짓을 반환

- 해당 클래스 뿐만 아니라 부모 클래스에 대해서도 인스턴스라고 판단





## 19. Object 클래스

- Java의 모든 클래스는 Object라는 클래스를 상속
- 유용한 메서드들이 존재



### getClass()

```java
<변수명>.getClass
```

- 실행 중에 개체의 클래스 정보를 얻어올 수 있음
- 반환된 개체(Class)에는 여러 유용한 메서드가 들어 있음



### getClass.getName()

```java
<변수명>.getClass.getName()
```

- 클래스 명을 반환하는 메서드
- 이때, 클래스명은 <u>패키지 경로까지 포함</u>





## 20. 다중 상속

- 잘못 사용하면 매우 복잡해짐
  - 가장 아랫줄은 최상위 부모를 여러 번 상속
- 따라서, Java는 다중 상속을 지원 안 함
- C++은 다중 상속을 지원



### 다중 상속이 생기는 이유

- 전혀 다른 양상(측면, Aspect)의 특징을 상속받으려 함
- 여러가지 양상의 특징을 상속으로 표현하려 하면 부자연스럽거나 복잡한 구조가 나옴



### 다중 상속을 해결하는 방법

- 비슷한 개념을 포괄 할수 있는 개념으로 추상화
  - 단, 너무 심한 추상화는 의미를 해칠 수도 있음
- 인터페이스(interface)를 활용